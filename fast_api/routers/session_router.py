"""
Session Router

API endpoints for chat session management with persistent storage.

Provides:
- Session CRUD operations
- Task tracking per session
- Session state recovery
- Real-time task status polling
"""

import logging
from datetime import datetime
from typing import Dict, Any, List, Optional
from fastapi import APIRouter, HTTPException, Query
from pydantic import BaseModel, Field

from services.session_db import session_db, TaskStatus, StepType

logger = logging.getLogger(__name__)
router = APIRouter(prefix="/sessions", tags=["sessions"])


# ============== Request/Response Models ==============

class CreateSessionRequest(BaseModel):
    """Request to create a new session"""
    session_id: str = Field(..., description="Unique session ID (from frontend)")
    title: str = Field(default="New Chat", description="Session title")


class UpdateSessionRequest(BaseModel):
    """Request to update session"""
    title: Optional[str] = None
    status: Optional[str] = None
    metadata: Optional[Dict[str, Any]] = None


class SessionResponse(BaseModel):
    """Session information response"""
    session_id: str
    title: str
    created_at: str
    updated_at: str
    status: str
    metadata: Dict[str, Any] = {}


class TaskSummary(BaseModel):
    """Summary of a task"""
    task_uid: str
    agent_name: str
    task_type: str
    status: str
    created_at: str
    started_at: Optional[str] = None
    completed_at: Optional[str] = None


class SessionStateResponse(BaseModel):
    """Complete session state for recovery"""
    session: Dict[str, Any]
    messages: List[Dict[str, Any]]
    tasks: List[Dict[str, Any]]
    running_tasks: List[Dict[str, Any]]
    task_stats: Dict[str, int]
    agents_involved: List[str]
    is_processing: bool


class RunningTasksResponse(BaseModel):
    """Response for running tasks query"""
    session_id: Optional[str]
    tasks: List[Dict[str, Any]]
    count: int


# ============== Session Endpoints ==============

@router.post("/", response_model=SessionResponse)
async def create_session(request: CreateSessionRequest):
    """
    Create a new chat session.
    
    The session_id should be generated by the frontend to enable
    immediate use before server confirmation.
    """
    try:
        session = session_db.create_session(request.session_id, request.title)
        return SessionResponse(**session.to_dict())
    except Exception as e:
        logger.error(f"Error creating session: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/", response_model=List[SessionResponse])
async def list_sessions(
    status: Optional[str] = Query(None, description="Filter by status"),
    limit: int = Query(50, ge=1, le=200)
):
    """List all sessions"""
    try:
        sessions = session_db.list_sessions(status=status, limit=limit)
        return [SessionResponse(**s.to_dict()) for s in sessions]
    except Exception as e:
        logger.error(f"Error listing sessions: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/{session_id}", response_model=SessionResponse)
async def get_session(session_id: str):
    """Get a specific session"""
    session = session_db.get_session(session_id)
    if not session:
        raise HTTPException(status_code=404, detail="Session not found")
    return SessionResponse(**session.to_dict())


@router.patch("/{session_id}", response_model=SessionResponse)
async def update_session(session_id: str, request: UpdateSessionRequest):
    """Update a session"""
    session = session_db.get_session(session_id)
    if not session:
        raise HTTPException(status_code=404, detail="Session not found")
    
    updates = request.model_dump(exclude_unset=True)
    if updates:
        session_db.update_session(session_id, **updates)
    
    session = session_db.get_session(session_id)
    return SessionResponse(**session.to_dict())


@router.delete("/{session_id}")
async def delete_session(
    session_id: str,
    hard_delete: bool = Query(False, description="Permanently delete")
):
    """Delete or archive a session"""
    session = session_db.get_session(session_id)
    if not session:
        raise HTTPException(status_code=404, detail="Session not found")
    
    session_db.delete_session(session_id, hard_delete=hard_delete)
    return {"success": True, "session_id": session_id}


# ============== Session State Endpoints ==============

@router.get("/{session_id}/state", response_model=SessionStateResponse)
async def get_session_state(session_id: str):
    """
    Get complete session state for recovery.
    
    Returns everything needed to restore a session:
    - Session metadata
    - All messages
    - All tasks with their status
    - All steps (for thinking visualization)
    - Summary statistics
    
    Use this when:
    - User returns to a chat tab
    - Recovering from page refresh
    - Syncing state across devices
    """
    state = session_db.get_session_state(session_id)
    if not state:
        raise HTTPException(status_code=404, detail="Session not found")
    
    return SessionStateResponse(**state)


@router.get("/{session_id}/messages")
async def get_session_messages(
    session_id: str,
    limit: int = Query(100, ge=1, le=500)
):
    """Get all messages for a session"""
    session = session_db.get_session(session_id)
    if not session:
        raise HTTPException(status_code=404, detail="Session not found")
    
    messages = session_db.get_session_messages(session_id, limit=limit)
    return {"session_id": session_id, "messages": messages, "count": len(messages)}


@router.get("/{session_id}/tasks")
async def get_session_tasks(
    session_id: str,
    status: Optional[str] = Query(None, description="Filter by status"),
    include_steps: bool = Query(False, description="Include task steps")
):
    """Get all tasks for a session"""
    session = session_db.get_session(session_id)
    if not session:
        raise HTTPException(status_code=404, detail="Session not found")
    
    task_status = TaskStatus(status) if status else None
    tasks = session_db.get_session_tasks(session_id, status=task_status, include_steps=include_steps)
    return {"session_id": session_id, "tasks": tasks, "count": len(tasks)}


@router.get("/{session_id}/tasks/running", response_model=RunningTasksResponse)
async def get_running_tasks(session_id: str):
    """
    Get all running/pending tasks for a session.
    
    Use this for polling to check if work is still in progress.
    """
    session = session_db.get_session(session_id)
    if not session:
        raise HTTPException(status_code=404, detail="Session not found")
    
    tasks = session_db.get_running_tasks(session_id)
    return RunningTasksResponse(
        session_id=session_id,
        tasks=tasks,
        count=len(tasks)
    )


@router.get("/{session_id}/steps")
async def get_session_steps(
    session_id: str,
    limit: int = Query(100, ge=1, le=500)
):
    """Get all task steps for a session (for thinking visualization)"""
    session = session_db.get_session(session_id)
    if not session:
        raise HTTPException(status_code=404, detail="Session not found")
    
    steps = session_db.get_session_steps(session_id, limit=limit)
    return {"session_id": session_id, "steps": steps, "count": len(steps)}


# ============== Task Endpoints ==============

@router.get("/tasks/{task_uid}")
async def get_task(task_uid: str):
    """Get a specific task by UID"""
    task = session_db.get_task(task_uid)
    if not task:
        raise HTTPException(status_code=404, detail="Task not found")
    return task.to_dict()


@router.get("/tasks/{task_uid}/steps")
async def get_task_steps(task_uid: str):
    """Get all steps for a specific task"""
    task = session_db.get_task(task_uid)
    if not task:
        raise HTTPException(status_code=404, detail="Task not found")
    
    steps = session_db.get_task_steps(task_uid)
    return {"task_uid": task_uid, "steps": steps, "count": len(steps)}


# ============== Global Task Endpoints ==============

@router.get("/tasks/running/all", response_model=RunningTasksResponse)
async def get_all_running_tasks():
    """
    Get all running/pending tasks across all sessions.
    
    Use this for global system monitoring.
    """
    tasks = session_db.get_running_tasks()
    return RunningTasksResponse(
        session_id=None,
        tasks=tasks,
        count=len(tasks)
    )
